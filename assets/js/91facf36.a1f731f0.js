"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7078],{5591:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>g});var i=n(8527);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,g=u["".concat(l,".").concat(d)]||u[d]||h[d]||o;return n?i.createElement(g,r(r({ref:t},p),{},{components:n})):i.createElement(g,r({ref:t},p))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3390:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(4465),a=(n(8527),n(5591));const o={title:"06 - Splitting"},r="Splitting (and Chunking)",s={unversionedId:"tutorial/splitting",id:"tutorial/splitting",title:"06 - Splitting",description:"Let's say you want to summarize a long document. You could divide the document into an array of smaller pieces of text (chunking), and then iterate over each piece of text to summarize it (splitting), before summarizing the summaries.",source:"@site/docs/tutorial/06-splitting.md",sourceDirName:"tutorial",slug:"/tutorial/splitting",permalink:"/docs/tutorial/splitting",draft:!1,editUrl:"https://github.com/ironclad/rivet/tree/main/packages/docs/docs/tutorial/06-splitting.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"06 - Splitting"},sidebar:"tutorial",previous:{title:"05 - Subgraphs",permalink:"/docs/tutorial/subgraphs"},next:{title:"07 - Loops",permalink:"/docs/tutorial/loops"}},l={},c=[{value:"Chunking",id:"chunking",level:2},{value:"Splitting",id:"splitting",level:2},{value:"Combining",id:"combining",level:2}],p={toc:c},u="wrapper";function h(e){let{components:t,...o}=e;return(0,a.yg)(u,(0,i.A)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"splitting-and-chunking"},"Splitting (and Chunking)"),(0,a.yg)("p",null,"Let's say you want to summarize a long document. You could divide the document into an array of smaller pieces of text (chunking), and then iterate over each piece of text to summarize it (splitting), before summarizing the summaries."),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},'For this tutorial, we will use the graph in the "6. Splitting" folder. Download the ',(0,a.yg)("a",{parentName:"p",href:"https://github.com/Ironclad/rivet/blob/main/packages/app/src/assets/tutorials/documentation-tutorial.rivet-project"},"documentation-tutorial.rivet-project here")," and open it in Rivet to follow along!")),(0,a.yg)("h2",{id:"chunking"},"Chunking"),(0,a.yg)("p",null,'The first step of dividing a document into an array is called "chunking" in Rivet. The ',(0,a.yg)("a",{parentName:"p",href:"/docs/node-reference/chunk"},"Chunk Node")," takes a string, and divides it into chunks of a certain token size."),(0,a.yg)("p",null,"Try running the tutorial example, and notice that the Chunk Node output has N elements. Now, try increasing overlap to 50%. The output likely now has more than N elements. Overlap makes each chunk share some text from the beginning and end of the next and previous chunks. This is helpful to account for sentences or ideas that might otherwise be split across chunks."),(0,a.yg)("p",null,'In the screenshot below, you can see that "3.2 XYZ\'s Responsibilities" appears in both chunk 0 and 1, while "5. Compensation" appears in both chunk 1 and 2.'),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Chunking with Overlap",src:n(742).A,width:"3260",height:"1168"})),(0,a.yg)("h2",{id:"splitting"},"Splitting"),(0,a.yg)("p",null,'The next step is iterating over each piece of text in the array. In Rivet, nodes have a "split mode," which allows them to iterate over arrays. When split mode is on, the split icon (circled below in red) will show next to the node title.'),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Split node icon",src:n(7845).A,width:"327",height:"296"})),(0,a.yg)("p",null,"Try running the tutorial example, and notice that the Text Node outputs an array, with the text chunks inserted into the template."),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Split node output",src:n(9423).A,width:"1861",height:"1260"})),(0,a.yg)("p",null,'Now, turn off split mode, and run the graph. Notice that the output is a single string, with the chunk items all concatenated together ("This is chunk 1 2 3 4..." is happening because the ',(0,a.yg)("inlineCode",{parentName:"p"},"index")," input is also an array). This is eventually how we will transform the array of summaries into a single answer."),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Split node off",src:n(7141).A,width:"1884",height:"1104"})),(0,a.yg)("p",null,"Split mode can be configured with max and sequential. Max specifies the max iterations. Try setting it to 2, and notice that the remaining items get ignored. Sequential specifies whether to iterate over items one at a time, or in parallel."),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Split node configuration",src:n(5758).A,width:"492",height:"308"})),(0,a.yg)("p",null,"Now, notice that the Text Node has three inputs: ",(0,a.yg)("inlineCode",{parentName:"p"},"index"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"count"),", and ",(0,a.yg)("inlineCode",{parentName:"p"},"data"),". ",(0,a.yg)("inlineCode",{parentName:"p"},"index")," is an array of sequential numbers, from 0 to N. ",(0,a.yg)("inlineCode",{parentName:"p"},"data")," is the array of N text chunks. In split mode, these arrays are iterated over together, so that the i-th index is processed with the i-th text chunk. The ",(0,a.yg)("inlineCode",{parentName:"p"},"count")," input is not an array, so it will stay constant throughout."),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"Warning: Try to keep input arrays to split nodes the same length. Otherwise, Rivet will go back to the start of any arrays that are shorter (which is unlikely to be the behavior you're looking for).")),(0,a.yg)("h2",{id:"combining"},"Combining"),(0,a.yg)("p",null,"You can link nodes with split mode enabled to transform each item in an array. In the tutorial example, notice the split icon across the three nodes in the middle (Text, Chat, Text). The first Text Node inserts each chunk into a prompt template for summarization. Then, the Chat Node summarizes each chunk individually. Finally, the other Text Node adds some context for the summary."),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Sequence of split nodes",src:n(3550).A,width:"2688",height:"586"})),(0,a.yg)("p",null,'The resulting string array of summaries (and context about which chunk the summary comes from) is then combined into a Text Node with split mode turned off. By default, the string array input will get "coerced" into a string type by concatenating each item with a newline. If you want to combine them in a different way, consider something like the ',(0,a.yg)("a",{parentName:"p",href:"/docs/node-reference/join"},"Join Node"),"."))}h.isMDXComponent=!0},742:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/06-chunking-with-overlap-bb5e7e3855bbdfbc50a532f8f521ec9f.png"},5758:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/06-split-node-config-e91e3e5ac22619d981d68600f72eebde.png"},7141:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/06-split-node-off-0a40c81022cc1811d182d68fa50706de.png"},9423:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/06-split-node-output-2b32ef404a5e8024a3a90bda774c5572.png"},7845:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/06-split-node-6fb563727744551c1be29851f120fc45.png"},3550:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/06-split-sequence-5ca0adb1852a8b03bd1bf27c4bf74859.png"}}]);