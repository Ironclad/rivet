"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6071],{1042:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>m});var r=a(3249);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var u=r.createContext({}),l=function(e){var t=r.useContext(u),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,u=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),d=l(a),c=n,m=d["".concat(u,".").concat(c)]||d[c]||h[c]||o;return a?r.createElement(m,i(i({ref:t},s),{},{components:a})):r.createElement(m,i({ref:t},s))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=c;var p={};for(var u in t)hasOwnProperty.call(t,u)&&(p[u]=t[u]);p.originalType=e,p[d]="string"==typeof e?e:n,i[1]=p;for(var l=2;l<o;l++)i[l]=a[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}c.displayName="MDXCreateElement"},1386:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>p,toc:()=>l});var r=a(7396),n=(a(3249),a(1042));const o={sidebar_label:"Validation Graphs"},i="Trivet - Validator Graphs",p={unversionedId:"user-guide/trivet-validation-graphs",id:"user-guide/trivet-validation-graphs",title:"Trivet - Validator Graphs",description:"Instead of using baked-in validations, Trivet uses Rivet graphs to perform validation on your test graph. This allows you the ultimate flexibility in how you want to validate your graph. It is common to make LLM calls to validate your graph - a great pattern is asking an LLM to respond with YES or NO after asking it a question, and then using a Match node to find either the YES or NO.",source:"@site/docs/user-guide/trivet-validation-graphs.md",sourceDirName:"user-guide",slug:"/user-guide/trivet-validation-graphs",permalink:"/docs/user-guide/trivet-validation-graphs",draft:!1,editUrl:"https://github.com/ironclad/rivet/tree/main/packages/docs/docs/user-guide/trivet-validation-graphs.md",tags:[],version:"current",frontMatter:{sidebar_label:"Validation Graphs"},sidebar:"userGuide",previous:{title:"Getting Started",permalink:"/docs/user-guide/trivet-getting-started"},next:{title:"Tutorial",permalink:"/docs/user-guide/trivet-tutorial"}},u={},l=[{value:"<code>input</code> Input",id:"input-input",level:2},{value:"<code>output</code> Output",id:"output-output",level:2},{value:"<code>expectedOutput</code> Output",id:"expectedoutput-output",level:2},{value:"Outputs",id:"outputs",level:2}],s={toc:l},d="wrapper";function h(e){let{components:t,...o}=e;return(0,n.kt)(d,(0,r.Z)({},s,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"trivet---validator-graphs"},"Trivet - Validator Graphs"),(0,n.kt)("p",null,"Instead of using baked-in validations, Trivet uses Rivet graphs to perform validation on your test graph. This allows you the ultimate flexibility in how you want to validate your graph. It is common to make LLM calls to validate your graph - a great pattern is asking an LLM to respond with ",(0,n.kt)("inlineCode",{parentName:"p"},"YES")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"NO")," after asking it a question, and then using a ",(0,n.kt)("a",{parentName:"p",href:"../node-reference/match"},"Match")," node to find either the YES or NO."),(0,n.kt)("p",null,"Select the validator graph using the dropdown at the top:"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Validator Graph Dropdown",src:a(5368).Z,width:"395",height:"167"})),(0,n.kt)("p",null,"A validator graph is a specially constructed Rivet graph, with the following requirements:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"It must have an Graph Input node named ",(0,n.kt)("inlineCode",{parentName:"li"},"input")," of type Object."),(0,n.kt)("li",{parentName:"ul"},"It must have a Graph Input node named ",(0,n.kt)("inlineCode",{parentName:"li"},"output")," of type Object."),(0,n.kt)("li",{parentName:"ul"},"It must have a Graph Input node named ",(0,n.kt)("inlineCode",{parentName:"li"},"expectedOutput")," of type Object."),(0,n.kt)("li",{parentName:"ul"},'It must have any number of Graph Output nodes that must be either String, or Boolean. These are the "validations" that the graph performs.')),(0,n.kt)("p",null,"You may choose any of these input nodes, or you may ignore any of them to perform your validation."),(0,n.kt)("h2",{id:"input-input"},(0,n.kt)("inlineCode",{parentName:"h2"},"input")," Input"),(0,n.kt)("p",null,"This an object representing the inputs which were passed into the Test graph. It is an Object type where each property corresponds to one of the inputs to the Test graph."),(0,n.kt)("h2",{id:"output-output"},(0,n.kt)("inlineCode",{parentName:"h2"},"output")," Output"),(0,n.kt)("p",null,"This an object representing the outputs which were returned from the Test graph. It is an Object type where each property corresponds to one of the outputs from the Test graph."),(0,n.kt)("h2",{id:"expectedoutput-output"},(0,n.kt)("inlineCode",{parentName:"h2"},"expectedOutput")," Output"),(0,n.kt)("p",null,"This is an object representing the expected outputs from the Test graph. It is an Object type that is passed in to the validation graph from the test case. The properties will exactly match the properties on the ",(0,n.kt)("inlineCode",{parentName:"p"},"output")," object, however the actual values can be anything you wish."),(0,n.kt)("p",null,"A common pattern is, if the validation graph is performing an LLM call to check the result, for each expected output to be a plain statement validation you are asking about the corresponding ",(0,n.kt)("inlineCode",{parentName:"p"},"output"),". For example, if you have the output:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "John Doe",\n  "age": 42\n}\n')),(0,n.kt)("p",null,"Then you might have the expected output:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "The name must be John Doe.",\n  "age": "The age must be 42."\n}\n')),(0,n.kt)("h2",{id:"outputs"},"Outputs"),(0,n.kt)("p",null,"The outputs of the validator graph are the validations that are performed. Each output must be either a String or a Boolean. If it is a String, then it must be truthy such as ",(0,n.kt)("inlineCode",{parentName:"p"},'"true"')," or ",(0,n.kt)("inlineCode",{parentName:"p"},'"false"'),". If it is a Boolean, then it is a boolean validation."),(0,n.kt)("p",null,"In the future, we may allow outputs to specify what went wrong with a validation."))}h.isMDXComponent=!0},5368:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/trivet-validator-graph-dropdown-c88a21ef37533587699f54ece4dea5e0.png"}}]);